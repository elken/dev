:page/title Bundling ClojureScript to leverage Modern JavaScript
:blog-post/author {:person/id :lkn}
:blog-post/created-at 2024-02-24
:blog-post/tags [:clojure :clojurescript :javascript]
:blog-post/header-image /header/images/shadow-cljs-webpack/preview.png
:open-graph/image /opengraph/shadow-cljs-webpack.png
:open-graph/description Bundling JavaScript like it's 2015
:blog-post/preview 
Writing ClojureScript is nice, until we need something from "modern JavaScript". If only there was a better way...
:page/body 

I've recently found myself leaning more on ClojureScript when it comes to
writing web applications. It brings a lot of pros to the mix, a few of which
include:

- A much more succinct syntax
- Related to the previous point, it's a really good fit for component-driven
  design since you can trivially nest and compose web components (functions)
- [A macro system](https://code.thheller.com/blog/shadow-cljs/2019/10/12/clojurescript-macros.html), _kind of_ [^1] 
- The ability to write cross-domain code[^2] 

Overall, it's really great. Coupled with something like
[uix](https://github.com/pitch-io/uix) it makes writing React applications
simple.

...that is until you rely on a library like
[react-query](https://tanstack.com/query/latest/docs/framework/react/overview)
(for the purposes of this article, you don't need to understand or even be aware
of what it does).

## A brief tangent

So, in order to explain the problem we need to go over some context with
ClojureScript. If you're already familiar with the internals of ClojureScript,
feel free to skip this section.

ClojureScript relies on the [Google
Closure](https://developers.google.com/closure/compiler/) compiler to emit its
code, and as such any and all features from upstream JavaScript also have to be
implemented there. The problem that we have is that some features that "modern
JavaScript" rely on are not implemented yet in Closure, e.g. [Class
fields](https://github.com/google/closure-compiler/issues/2731).

There's nothing inherent "we" can do (except implement the code and see it
through of course), so while we wait for these features to be added we have to
make do.

Surely there's a way we can leverage these modern features?

## Leveraging these modern features

Among shadow-cljs' numerous options is the ability to specify a
[:js-provider](https://shadow-cljs.github.io/docs/UsersGuide.html#js-provider)
which includes a number of options, the one we care about here is `:external`.

What this option in particular does is instructs shadow-cljs to not handle the
various `require` statements and just emit a single index file. With this index
file, we can pass it to some other JavaScript bundler (webpack, for our
purposes) and have _that_ handle our bundling.

By adding a small overhead (more on that later) and an "extra compile step"
(welcome to the web), we can write ClojureScript as we normally would including
using 3rd party libraries that rely on these "modern features" just as we would
in regular JavaScript.

### Setup

For these purposes, I'll run through a simple ClojureScript app I was tinkering
around with.

`shadow-cljs.edn`
```clojure {data-line="10,12-13"}
{:dev-http {3000 "./resources/public/"}
 :source-paths ["src"]
 :dependencies
 [[com.pitch/uix.core "1.0.1"]
  [com.cognitect/transit-cljs "0.8.280"]
  [com.pitch/uix.dom "1.0.1"]]
 :builds
 {:main
  {:target :browser
   :output-dir "resources/public/js"
   :asset-path "/js"
   :js-options {:js-provider :external}
   :compiler-options {:source-map true}
   :devtools {:preloads [snippets.preloads]}
   :modules {:main {:init-fn snippets.core/init
                    :entries [snippets.core]}}
   :release {:target :browser
             :output-dir "dist/js"
             :asset-path "/js"
             :modules {:main {:entries [snippets.core]}}}}}}
```

The highlighted lines are the only ones we care about. The first one is where
our JavaScript is produced, which we'll need later. The other lines are the only
setup we need to get this working. Once we have this and we build our project,
we instead produce a file which by default lives in `target/external.js` and
looks like the following

```javascript
// WARNING: DO NOT EDIT!
// THIS FILE WAS GENERATED BY SHADOW-CLJS AND WILL BE OVERWRITTEN!

var ALL = {};
ALL["react-dom/client"] = require("react-dom/client");
ALL["react-refresh/runtime"] = require("react-refresh/runtime");
ALL["@uiw/codemirror-theme-atomone"] = require("@uiw/codemirror-theme-atomone");
ALL["@uiw/codemirror-extensions-langs"] = require("@uiw/codemirror-extensions-langs");
ALL["react-dom"] = require("react-dom");
ALL["@uiw/codemirror-extensions-color"] = require("@uiw/codemirror-extensions-color");
ALL["highlight.js"] = require("highlight.js");
ALL["@uiw/react-codemirror"] = require("@uiw/react-codemirror");
ALL["react-router-dom"] = require("react-router-dom");
ALL["react"] = require("react");
global.shadow$bridge = function shadow$bridge(name) {
  var ret = ALL[name];

  if (ret === undefined) {
     throw new Error("Dependency: " + name + " not provided by external JS. Do you maybe need a recompile?");
  }

  return ret;
};

shadow$bridge.ALL = ALL;
```

Great! We have all our dependencies without any transformations applied. This
isn't wasted on this project, as we have a down-the-line dependency that breaks
thanks to [this issue](https://github.com/lezer-parser/php/issues/3) (JavaScript
is a _great_ ecosystem), so without this setup we can't build.

Now that we have this, what's next? Well, we need to point `webpack-cli` at this
file and have it produce its output to the same place shadow-cljs emits _your_
code, and then our `index.html` can just include it before anything else and
we're away.

We can take care of `webpack-cli` with the following:

```sh {.command-line .no-line-numbers data-continuation-str="\"}
webpack-cli watch \
--entry ./target/external.js \
--output-path resources/public/js/libs \
--target web \
--mode development
```

(for simplicity I encourage you to make this an `npm` task)

Lastly, we have to include this new bundled JavaScript in our `index.html` as below (rest of the file omitted for brevity):

```html
<body>
    <div id="root"></div>

    <script src="/js/libs/main.js"></script>
    <script src="/js/main.js"></script>
</body>
```

**Make sure that the bundled JavaScript comes first**. 

I use a subdirectory to ensure that the `main.js` file it produces doesn't wipe
out my build, and it makes it clearer in the `index.html` which does what. If
you're using async on the script tags, I wouldn't recommend it here.

And that's it!

## Closing

I aimed to give some setup on using webpack with shadow-cljs, and some of you
might be wondering why shadow doesn't just use webpack to begin with. Well, this
has already [been
answered](https://code.thheller.com/blog/shadow-cljs/2018/06/15/why-not-webpack.html)
by someone much smarter than me. [Twice
actually](https://code.thheller.com/blog/shadow-cljs/2020/05/08/how-about-webpack-now.html).

I encourage you to try this out on your own projects, but if you find yourself
relying on more and more of the node ecosystem; you might be better off by just
using JavaScript. It's possible to [import
JavaScript](https://shadow-cljs.github.io/docs/UsersGuide.html#classpath-js)
directly, though I wouldn't recommend this in production-level apps.

As with most things in software, use the best tool for the job.

## References/footnotes

[^1]: As noted in the article, the macros don't _technically_ run in CLJS but they are _used_ there
[^2]: By writing code in a .cljc namespace, you can utilize it in both Clojure and ClojureScript
